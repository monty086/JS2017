<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<input id='input' type="text">
<script>

    var reg = new RegExp;
  var reg = /a/i // ignore //忽略大小写
    var str = 'abc123'
    reg.test(str)  //测试：只要字符串中包含字母a就可以 返回true


    /*特殊的元字符
    *      \d :0-9之间的任意一个数字 （超过1个也可以） 只要字符串有一个数字就行，不在乎位置
    *      \d+:1到多位，
    *      \a\i:a是字母，i是忽略前面字母的大小写
    *      \d\d :必须有两个连续出现的数字
    *      \w :代表数字、字母、下划线  0-9  a-z  A-Z _   代表这些，也是数字字母下划线中的一个，也是一个
    *      \w\d :表示数字必须在数字字母下划线后面如果是   /1owueroqiwr/数字在前面就不行，因为前面是数字字母下划线，后面是数字，不能把顺序弄乱   /1owuer4oqiwr/这个就可以，前面不符合，中间符合就行
    *      \s :空格或者空白  在字符串中有一个空格按键就行（一个或多个以上），tab也行  空字符串也是假的
    *      \b : 边界：所谓的边界就是 字符串的开始和结束，一些特殊字符的两边也是边界（字符串的两头都是 一个边界，空格 、-、%、也是一个边界；而且他不占位置）//\'6a'\字母在右边就把边界占了，所以false\('6 a')\这个中间加一个空格，算是6的边界
    *      \n :匹配一个换行，在字符串中是换行的功能，'a\\nb'这个就是 回归他本来的意思 打印'a\nb'
    *      . : 匹配任意字符，除了\n（空字符串什么都没有是false）
    *      ^ :  以什么开始  ^/d$  6  当我对字符串的长度有限制的话，就可以加上，
    *      $ :  以什么结束
    *      ps： 如果^$同时出现，对于这个字符串的个数就限制了（会让正则更严谨）  对位数有限制需要加 ctrl+doller  不加ctyl+doller，只要字符串中出现前面的描述就可以，后面加一堆的字母也符合。所以一定要加开始和结束
    *      \.:  "."代表它本身  单一个\属于转译，代表它本身，不加\就属于任意字符了
    *      \ :  转义多添加一个\就行==》把特殊意义的字符转变成本来的意思
    *      \D :  除了\d （小d）其他的所有字符，如果加上\d  小d那就全部匹配了。
    *      \W :除了\w
    *      \S : 除了\s
    *
    *
    * */

    /*
    *   量词： 位置，放在要修饰元字符的后面==》修饰前面的元字符出现的次数
    *   +：1到多个   至少1个 \d+代表最少1个字符，最多没限制
    *   *：0到多个   可以有，可以没有 0次代表没有也可以
    *   ？：0-1个  要么有，要么没有，要么出现，要么不出现， ？代表有没有都行
    *   {n}：出现n个   {n}在后面表示前面的元素连续出现几次
    *   {n,}: 至少n个  最少n个
    *   {n,m}: 出现n到m个  {1,16}最少1位，最多16位
    *
    *
    * */
    /*
    *    正则中的或者
    *    1 x|y|z  占一个位置  x或者y中的一个，或者z中的一个
    *    |：或者，一条数线 满足一个条件就可以，字符串出现其中一个就可以，其他多出来就可以，如果要限制他的长度，^ $  /^18|19$/ 如果不加括号的话就是 '18lksdlfk'  '191283919'这两个都满足，如果要满足规则需要加一个括号 /^(18|19)$/
     *    由于或者关系满足其中的一个就可以，所以处理或者关系的时候，我们不妨使用（）去改变运算的优先级，把这一部分看做是一个整体，
     *    2. [xyz]  x或者y或者z中的一个  字符串中只要有一个就行了  中括号里面等于或者的意思
     *    3. [^xyz]  只要字符串中 有一个字符 不是x 不是y 也不是z 就为true 'axyz ' ；false：字符串中只有xyz；'xyzxyzyyz'为false ； ；；要求字符绝对纯净，只能有xyz，只要有任何其他数都是true，只有xyz的话，就是false
     *    4. [+-]:'+'或者'-'中的 一个  只要字符串中出现任意一个就行，也是或者的意思
     *    5. [\d\w]: 数字，字母，下划线中的任意一个，
     *    6. \w :[0-9a-zA-Z_]这里的-在[ ]表示 到 的意思
     *    7. [.]:中括号中的'.'代表的不是任意字符，代表'.'本身
     *    8. [0-9a-zA-Z_] ：可以当做或者输入
    *
    *
    * */


  //  /^/d{11}$/  手机号 {n}在后面表示连续出现
    var reg = /\w\d/;
    var str = '11'
    console.log(reg.test(str))

     var reg = /^[+-]?\d+(\.\d+)?$/;

    reg = /^\s*&/
    var input = document.getElementById('input');
    input.onblur = function (){
        if(reg.text(this.value)){
            alert('输入不能为空')
        }
    }
    //邮箱的内容

    //正则的创建方式
    //实例和字面量的区别，字面量用的多
    //1. 如果使用实例的创建方式，创建，当有特殊的元字符\d需要在创建的时候，需要在前面在加一个'\'（\\d）
    //2. 实例创建，在new的过程中的第二个参数，就是修饰符
    //3. 只要正则中有需要变量的时刻，那么就只能使用实例的创建方式


    /*
    * 修饰符：
    *       i：ignoreCase 在匹配的时候，忽略大小写
    *       m：multiline   多行匹配
    *       g：global  全局全文 （一般用于捕获exec） 用的比较多
    *
    *
    * */

    var reg = new RegExp('\\d')

    var reg =/name/   // 只要字符串中出现连续的name就行





</script>
</body>
</html>、